#! /usr/bin/env python
# Copyright (C) 2013 Nicira, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Limitations:
#     - Doesn't support multicast other than "unknown-dst"

import argparse
import re
import shlex
import subprocess
import sys
import time
import types

import ovs.dirs
import ovs.util
import ovs.daemon
import ovs.unixctl.server
import ovs.vlog
from six.moves import range
import six


VERSION = "0.99"

root_prefix = ""

__pychecker__ = 'no-reuseattr'  # Remove in pychecker >= 0.8.19.
vlog = ovs.vlog.Vlog("ovs-vtep")
exiting = False

ps_name = ""
ps_type = ""
Tunnel_Ip = ""
Lswitches = {}
Lrouters = {}
Bindings = {}
Switch_Bindings = {}
ls_count = 0
lr_count = 0
tun_id = 0
bfd_bridge = "vtep_bfd"
bfd_ref = {}


def call_prog(prog, args_list):
    cmd = [prog, "-vconsole:off"] + args_list
    output = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()
    if len(output) == 0 or output[0] is None:
        output = ""
    else:
        output = output[0].strip()

    return output


def ovs_vsctl(args):
    return call_prog("ovs-vsctl", shlex.split(args))


def ovs_ofctl(args):
    return call_prog("ovs-ofctl", shlex.split(args))


def vtep_ctl(args):
    return call_prog("vtep-ctl", shlex.split(args))


def unixctl_exit(conn, unused_argv, unused_aux):
    global exiting
    exiting = True
    conn.reply(None)


class Logical_Router(object):
    def __init__(self, lr_name):
        global lr_count
        self.name = lr_name
        #lr_count += 1
        #self.short_name = "vtep_lr" + str(lr_count)
        self.short_name = "vtep_" + lr_name
        vlog.info("creating lrouter %s (%s)" % (self.name, self.short_name))
        self.ports = {}
        self.dst_ips = {}
        self.lifs = {}
        self.setup_lr()

    def __del__(self):
        vlog.info("destroying lrouter %s" % self.name)

    def setup_lr(self):
        if ps_type:
            ovs_vsctl("--may-exist add-br %s -- set Bridge %s datapath_type=%s"
                      % (self.short_name, self.short_name, ps_type))
        else:
            ovs_vsctl("--may-exist add-br %s" % self.short_name)

        ovs_vsctl("br-set-external-id %s vtep_logical_router true"
                  % self.short_name)
        ovs_vsctl("br-set-external-id %s logical_router_name %s"
                  % (self.short_name, self.name))

        ovs_ofctl("del-flows %s" % self.short_name)
        ovs_ofctl("add-flow %s priority=0,action=drop" % self.short_name)

    def update_flood(self):
        flood_ports = self.ports.values()

        ovs_ofctl("add-flow %s table=1,priority=0,action=%s"
                  % (self.short_name, ",".join(flood_ports)))

    def run(self):
        #vlog.info("start lrouter running")
        self.update_lif_macs()
        self.update_forwarding_macs()

    def update_lif_macs(self):
        lif_pl_uuid = vtep_ctl("--columns=_uuid find Physical_Locator dst_ip=127.0.0.1").partition(":")[2].strip()
        new_lifs = set()

        # update lif macs
        for switch_binding in Switch_Bindings.keys():
            lr_name, lif = switch_binding.split("-", 1)
            if lr_name != self.name:
                continue

            ls_name = Switch_Bindings[switch_binding]
            ls_uuid = get_logical_switch_uuid(ls_name)
            lif_mac_column = vtep_ctl("--columns=MAC find Ucast_Macs_Remote logical_switch=%s locator=%s"
                                      % (ls_uuid, lif_pl_uuid))

            if not lif_mac_column:
                continue

            lif_ip = lif.strip("\"").partition("(")[2].partition("/")[0]
            lif_ip_mask = lif.strip("\"").partition("(")[2].strip(")")
            lif_port_r = lif.strip("\"").partition("(")[0].strip() + "-r"
            lif_mac = lif_mac_column.partition(":")[2].strip()

            new_lifs.add(lif)
            if lif in self.lifs.keys():
                if self.lifs[lif] == lif_mac:
                    continue
                else:
                    del self.lifs[lif]
                    ovs_ofctl("del-flow %s ip,nw_dst=%s" % (self.short_name, lif_ip_mask))

            self.lifs[lif] = lif_mac

            # get ip's hex format
            lif_ip_hex = getHexIp(lif_ip)
            lif_mac_hex = "0x" + "".join(lif_mac.strip("\"").split(":"))

            # create ARP flow table
            ovs_ofctl("add-flow %s table=1,dl_type=0x0806,nw_dst=%s,actions="
                      "move:NXM_OF_ETH_SRC[]->NXM_OF_ETH_DST[],mod_dl_src:%s,"
                      "load:0x2->NXM_OF_ARP_OP[],move:NXM_NX_ARP_SHA[]->NXM_NX_ARP_THA[],"
                      "move:NXM_OF_ARP_SPA[]->NXM_OF_ARP_TPA[],"
                      "load:%s->NXM_NX_ARP_SHA[],"
                      "load:%s->NXM_OF_ARP_SPA[],in_port"
                      % (self.short_name, lif_ip, lif_mac, lif_mac_hex, lif_ip_hex))

            # don't flood arp request from same subnet (except gateway) to other lif
            ovs_ofctl("add-flow %s table=1,priority=1,in_port=%s,dl_type=0x0806,nw_dst=%s,action=drop"
                      % (self.short_name, self.ports[lif_port_r], lif_ip_mask))

            ovs_ofctl("add-flow %s table=2,priority=1,dl_type=0x0800,nw_dst=%s,action=mod_dl_src=%s,dec_ttl,resubmit(,3)"
                      % (self.short_name, lif_ip_mask, lif_mac))

        dead_lifs = set(self.lifs.keys()).difference(new_lifs)
        for lif in dead_lifs:
            del self.lifs[lif]
            lif_ip_mask = lif.strip("\"").partition("(")[2].strip(")")
            ovs_ofctl("del-flow %s ip,nw_dst=%s" % (self.short_name, lif_ip_mask))

    def update_forwarding_macs(self):
        # update lif macs
        lif_pl_uuid = vtep_ctl("--columns=_uuid find Physical_Locator dst_ip=127.0.0.1").partition(":")[2].strip()

        new_dst_ips = set()
        for switch_binding in Switch_Bindings.keys():
            lr_name, lif = switch_binding.split("-", 1)
            if lr_name != self.name:
                continue

            ls_name = Switch_Bindings[switch_binding]
            ls_uuid = get_logical_switch_uuid(ls_name)
            lif_port = lif.strip("\"").partition("(")[0].strip() + "-r"

            new_dst_ips = new_dst_ips | self.update_forward_macs_by_table(ls_uuid, lif_pl_uuid, "Ucast_Macs_Local", lif_port)
            new_dst_ips = new_dst_ips | self.update_forward_macs_by_table(ls_uuid, lif_pl_uuid, "Ucast_Macs_Remote", lif_port)

        dead_ips = set(self.dst_ips.keys()).difference(new_dst_ips)
        for ip in dead_ips:
            ovs_ofctl("del-flows %s ip,nw_dst=%s" % (self.short_name, ip))
            ovs_ofctl("del-flows %s dl_dst=%s" % (self.short_name, self.dst_ips[ip]))
            del self.dst_ips[ip]


    def update_forward_macs_by_table(self, ls_uuid, lif_pl_uuid, table, lif_port):
        columns = vtep_ctl("--columns=locator find %s logical_switch=%s" % (table, ls_uuid)).splitlines()
        new_dst_ips = set()

        for column in columns:
            if not column:
                continue

            pl_uuid = column.partition(":")[2].strip()
            if pl_uuid == lif_pl_uuid:
                continue

            ipaddr_lines = vtep_ctl("--columns=ipaddr find %s logical_switch=%s locator=%s" % (table, ls_uuid, pl_uuid)).splitlines()
            for ipaddr_line in ipaddr_lines:
                ipaddr = ipaddr_line.partition(":")[2].strip()
                if not ipaddr:
                    continue

                dst_ip = ipaddr.strip("\"").partition("(")[2].strip(")")
                new_dst_ips.add(dst_ip)

                # get destination's mac address from table
                column = vtep_ctl("--columns=MAC find %s logical_switch=%s ipaddr=%s"
                                  % (table, ls_uuid, ipaddr))
                dst_mac = column.partition(":")[2].strip()

                if dst_ip in self.dst_ips.keys():
                    if self.dst_ips[dst_ip] == dst_mac:
                        continue
                    else:
                        ovs_ofctl("del-flows %s ip,nw_dst=%s" % (self.short_name, dst_ip))
                        ovs_ofctl("del-flows %s dl_dst=%s" % (self.short_name, self.dst_ips[dst_ip]))
                        del self.dst_ips[dst_ip]

                self.dst_ips[dst_ip] = dst_mac
                ovs_ofctl("add-flow %s table=3,priority=1000,dl_type=0x0800,nw_dst=%s,action=mod_dl_dst:%s,dec_ttl,output:%s"
                          % (self.short_name, dst_ip, dst_mac, self.ports[lif_port]))

        return new_dst_ips

    # binding logical switch's LIF with local router which
    def add_switch_binding(self, binding, ls):
        vlog.info("adding switch binding %s" % binding)

        lr_name, lif = binding.split("-", 1)
        lif_port = lif.strip("\"").partition("(")[0].strip()
        lif_port_r = lif_port+"-r"
        lif_port_s = lif_port+"-s"

        lif_ip = lif.strip("\"").partition("(")[2].partition("/")[0]
        lif_ip_mask = lif.strip("\"").partition("(")[2].strip(")")

        #Create a patch port that connects the Logical Switch to the Logical Router
        ovs_vsctl("add-port %s %s "
                  " -- set Interface %s type=patch options:peer=%s"
                  % (ls.short_name, lif_port_s, lif_port_s, lif_port_r))
        ovs_vsctl("add-port %s %s "
                  " -- set Interface %s type=patch options:peer=%s"
                  % (self.short_name, lif_port_r, lif_port_r, lif_port_s))

        port_s_no = ovs_vsctl("get Interface %s ofport" % lif_port_s)
        port_r_no = ovs_vsctl("get Interface %s ofport" % lif_port_r)

        # create flow to switch to arp table whenever it is arp packet
        #ovs_ofctl("add-flow %s table=0,priority=1000,dl_type=0x0806,actions=resubmit(,1)" % self.short_name)

        # create flow to switch to routing table for other packets
        ovs_ofctl("add-flow %s table=0,priority=1,actions=resubmit(,2)" % self.short_name)

        ls.add_lbinding(lif_port_s)
        self.add_lbinding(lif_port_r)

    def add_lbinding(self, lbinding):
        vlog.info("adding %s binding to %s" % (lbinding, self.name))
        port_no = ovs_vsctl("get Interface %s ofport" % lbinding)
        self.ports[lbinding] = port_no
        ovs_ofctl("add-flow %s dl_type=0x0806,action=learn(table=1,"
        #          "priority=1000,idle_timeout=15,cookie=0x5000,"
                  "priority=1000,cookie=0x5000,"
                  "NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],"
                  "output:NXM_OF_IN_PORT[]),resubmit(,1)"
                  % (self.short_name))

        self.update_flood()

    def del_lbinding(self, lbinding, lif):
        vlog.info("removing %s binding from %s" % (lbinding, self.name))
        port_no = self.ports[lbinding]
        ovs_ofctl("del-flows %s in_port=%s" % (self.short_name, port_no));
        del self.ports[lbinding]
        self.update_flood()

        lif_ip_mask = lif.strip("\"").partition("(")[2].strip(")")
        ovs_ofctl("del-flows %s ip,nw_dst=%s" % (self.short_name, lif_ip_mask));
        ovs_ofctl("del-flows %s arp,arp_tpa=%s" % (self.short_name, lif_ip_mask));

class Logical_Switch(object):
    def __init__(self, ls_name, ps_name):
        global ls_count
        self.name = ls_name
        ls_count += 1
        self.short_name = ps_name + "_vtep_ls" + str(ls_count)
        vlog.info("creating lswitch %s (%s)" % (self.name, self.short_name))
        self.ports = {}
        self.tunnels = {}
        self.local_macs = set()
        self.remote_macs = {}
        self.unknown_dsts = set()
        self.tunnel_key = 0
        self.logical_router = None
        self.setup_ls()
        self.replication_mode = "service_node"

    def __del__(self):
        vlog.info("destroying lswitch %s" % self.name)

    def setup_ls(self):
        column = vtep_ctl("--columns=tunnel_key find logical_switch "
                              "name=%s" % self.name)
        tunnel_key = column.partition(":")[2].strip()
        if tunnel_key and isinstance(eval(tunnel_key), types.IntType):
            self.tunnel_key = tunnel_key
            vlog.info("using tunnel key %s in %s"
                      % (self.tunnel_key, self.name))
        else:
            self.tunnel_key = 0
            vlog.warn("invalid tunnel key for %s, using 0" % self.name)

        if ps_type:
            ovs_vsctl("--may-exist add-br %s -- set Bridge %s datapath_type=%s"
                      % (self.short_name, self.short_name, ps_type))
        else:
            ovs_vsctl("--may-exist add-br %s" % self.short_name)

        ovs_vsctl("br-set-external-id %s vtep_logical_switch true"
                  % self.short_name)
        ovs_vsctl("br-set-external-id %s logical_switch_name %s"
                  % (self.short_name, self.name))

        # since so far L3 local/remote macs are persisted in DB instead of querying by arp request, so keep from clean for now.
        # will remove this limiation when arp resolution issue is solved
        #vtep_ctl("clear-local-macs %s" % self.name)
        vtep_ctl("add-mcast-local %s unknown-dst %s" % (self.name, Tunnel_Ip))

        ovs_ofctl("del-flows %s" % self.short_name)
        ovs_ofctl("add-flow %s priority=0,action=drop" % self.short_name)

    def cleanup_ls(self):
        for port_no, tun_name, remote_ip in six.itervalues(self.tunnels):
            del_bfd(remote_ip)

    def update_flood(self):
        flood_ports = list(self.ports.values())

        # Traffic flowing from one 'unknown-dst' should not be flooded to
        # port belonging to another 'unknown-dst'.
        for tunnel in self.unknown_dsts:
            port_no = self.tunnels[tunnel][0]
            ovs_ofctl("add-flow %s table=1,priority=1,in_port=%s,action=%s"
                        % (self.short_name, port_no, ",".join(flood_ports)))

        # Traffic coming from a VTEP physical port should always be flooded to
        # all the other physical ports that belong to that VTEP device and
        # this logical switch.  If the replication mode is service node then
        # send to one unknown_dst node (the first one here); else we assume the
        # replication mode is source node and we send the packet to all
        # unknown_dst nodes.
        for tunnel in self.unknown_dsts:
            port_no = self.tunnels[tunnel][0]
            flood_ports.append(port_no)
            if self.replication_mode == "service_node":
                break

        ovs_ofctl("add-flow %s table=1,priority=0,action=%s"
                  % (self.short_name, ",".join(flood_ports)))

    def add_lbinding(self, lbinding):
        vlog.info("adding %s binding to %s" % (lbinding, self.name))
        port_no = ovs_vsctl("get Interface %s ofport" % lbinding)
        self.ports[lbinding] = port_no
        ovs_ofctl("add-flow %s in_port=%s,action=learn(table=1,"
                  "priority=1000,idle_timeout=15,cookie=0x5000,"
                  "NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],"
                  "output:NXM_OF_IN_PORT[]),resubmit(,1)"
                  % (self.short_name, port_no))

        self.update_flood()

    def del_lbinding(self, lbinding):
        vlog.info("removing %s binding from %s" % (lbinding, self.name))
        port_no = self.ports[lbinding]
        ovs_ofctl("del-flows %s in_port=%s" % (self.short_name, port_no))
        del self.ports[lbinding]
        self.update_flood()

    def add_tunnel(self, tunnel):
        global tun_id
        vlog.info("adding tunnel %s" % tunnel)
        encap, ip = tunnel.split("/")

        if encap != "vxlan_over_ipv4":
            vlog.warn("unsupported tunnel format %s" % encap)
            return

        tun_id += 1
        tun_name = "vx" + str(tun_id)

        ovs_vsctl("add-port %s %s -- set Interface %s type=vxlan "
                  "options:key=%s options:remote_ip=%s"
                  % (self.short_name, tun_name, tun_name, self.tunnel_key, ip))

        for i in range(10):
            port_no = ovs_vsctl("get Interface %s ofport" % tun_name)
            if port_no != "-1":
                break
            elif i == 9:
                vlog.warn("couldn't create tunnel %s" % tunnel)
                ovs_vsctl("del-port %s %s" % (self.short_name, tun_name))
                return

            # Give the system a moment to allocate the port number
            time.sleep(0.5)

        self.tunnels[tunnel] = (port_no, tun_name, ip)

        add_bfd(ip)

        ovs_ofctl("add-flow %s table=0,priority=1000,in_port=%s,"
                  "actions=resubmit(,1)"
                  % (self.short_name, port_no))

    def del_tunnel(self, tunnel):
        vlog.info("removing tunnel %s" % tunnel)

        port_no, tun_name, remote_ip = self.tunnels[tunnel]
        ovs_ofctl("del-flows %s table=0,in_port=%s"
                    % (self.short_name, port_no))
        ovs_vsctl("del-port %s %s" % (self.short_name, tun_name))

        del_bfd(remote_ip)

        del self.tunnels[tunnel]

    def update_local_macs(self):
        flows = ovs_ofctl("dump-flows %s cookie=0x5000/-1,table=1"
                          % self.short_name).splitlines()
        macs = set()
        for f in flows:
            mac = re.split(r'.*dl_dst=(.*) .*', f)
            if len(mac) == 3:
                macs.add(mac[1])

        for mac in macs.difference(self.local_macs):
            vlog.info("adding local ucast %s to %s" % (mac, self.name))
            vtep_ctl("add-ucast-local %s %s %s" % (self.name, mac, Tunnel_Ip))

        for mac in self.local_macs.difference(macs):
            vlog.info("removing local ucast %s from %s" % (mac, self.name))
            vtep_ctl("del-ucast-local %s %s" % (self.name, mac))

        self.local_macs = macs

    def add_remote_mac(self, mac, tunnel):
        port_no = self.tunnels.get(tunnel, (0, ""))[0]
        if not port_no:
            return

        ovs_ofctl("add-flow %s table=1,priority=1000,dl_dst=%s,action=%s"
                  % (self.short_name, mac, port_no))

    def del_remote_mac(self, mac):
        ovs_ofctl("del-flows %s table=1,dl_dst=%s" % (self.short_name, mac))

    def update_remote_macs(self):
        remote_macs = {}
        unknown_dsts = set()
        tunnels = set()
        parse_ucast = True

        mac_list = vtep_ctl("list-remote-macs %s" % self.name).splitlines()
        for line in mac_list:
            if (line.find("mcast-mac-remote") != -1):
                parse_ucast = False
                continue

            entry = re.split(r'  (.*) -> (.*)', line)
            if len(entry) != 4:
                continue

            if parse_ucast:
                # exclude gateway's tunnel which has no meaning
                if entry[2].find("127.0.0.1") != -1:
                    continue
                remote_macs[entry[1]] = entry[2]
            else:
                if entry[1] != "unknown-dst":
                    continue

                unknown_dsts.add(entry[2])

            tunnels.add(entry[2])

        old_tunnels = set(self.tunnels.keys())

        for tunnel in tunnels.difference(old_tunnels):
            self.add_tunnel(tunnel)

        for tunnel in old_tunnels.difference(tunnels):
            self.del_tunnel(tunnel)

        for mac in six.iterkeys(remote_macs):
            if (self.remote_macs.get(mac) != remote_macs[mac]):
                self.add_remote_mac(mac, remote_macs[mac])

        for mac in six.iterkeys(self.remote_macs):
            if mac not in remote_macs:
                self.del_remote_mac(mac)

        self.remote_macs = remote_macs

        replication_mode = vtep_ctl("get logical_switch %s replication_mode"
                                    % self.name)

        # Replication mode is an optional column and if it is not set,
        # replication mode defaults to service_node.
        if replication_mode == "[]":
            replication_mode = "service_node"

        # If the logical switch level replication mode has changed then
        # update to that value.
        update_flood_set = False
        if replication_mode != self.replication_mode:
            self.replication_mode = replication_mode
            vlog.info("%s replication mode changed to %s" %
                      (self.name, self.replication_mode))
            update_flood_set = True

        if (self.unknown_dsts != unknown_dsts):
            self.unknown_dsts = unknown_dsts
            update_flood_set = True

        # If either the replication mode has changed or the unknown
        # destinations set has changed, update the flooding decision.
        if update_flood_set is True:
            self.update_flood()

    def update_stats(self):
        # Map Open_vSwitch's "interface:statistics" to columns of
        # vtep's logical_binding_stats. Since we are using the 'interface' from
        # the logical switch to collect stats, packets transmitted from it
        # is received in the physical switch and vice versa.
        stats_map = {'tx_packets': 'packets_to_local',
                     'tx_bytes': 'bytes_to_local',
                     'rx_packets': 'packets_from_local',
                     'rx_bytes': 'bytes_from_local'}

        # Go through all the logical switch's interfaces that end with "-l"
        # and copy the statistics to logical_binding_stats.
        for interface in six.iterkeys(self.ports):
            if not interface.endswith("-l"):
                continue
            # Physical ports can have a '-' as part of its name.
            vlan, remainder = interface.split("-", 1)
            pp_name, logical = remainder.rsplit("-", 1)
            uuid = vtep_ctl("get physical_port %s vlan_stats:%s"
                            % (pp_name, vlan))
            if not uuid:
                continue

            for mapfrom, mapto in six.iteritems(stats_map):
                value = ovs_vsctl("get interface %s statistics:%s"
                                % (interface, mapfrom)).strip('"')
                vtep_ctl("set logical_binding_stats %s %s=%s"
                        % (uuid, mapto, value))

    def run(self):
        self.update_local_macs()
        self.update_remote_macs()
        self.update_stats()


def get_vtep_tunnel(remote_ip):
    # Get the physical_locator record for the local tunnel end point.
    column = vtep_ctl("--columns=_uuid find physical_locator "
                      "dst_ip=%s" % Tunnel_Ip)
    local = column.partition(":")[2].strip()
    if not local:
        return (None, None, None)

    # Get the physical_locator record for the remote tunnel end point.
    column = vtep_ctl("--columns=_uuid find physical_locator "
                      "dst_ip=%s" % remote_ip)
    remote = column.partition(":")[2].strip()
    if not remote:
        return (None, None, None)

    column = vtep_ctl("--columns=_uuid find tunnel "
                      "local=%s remote=%s" % (local, remote))
    tunnel = column.partition(":")[2].strip()

    return (local, remote, tunnel)


def create_vtep_tunnel(remote_ip):
    local, remote, tunnel = get_vtep_tunnel(remote_ip)
    if not local or not remote:
        return None

    if not tunnel:
        vlog.info("creating tunnel record in vtep for remote_ip:%s"
                  % remote_ip)
        tunnel = vtep_ctl("add physical_switch %s tunnels @tun -- "
                          "--id=@tun create Tunnel local=%s remote=%s"
                          % (ps_name, local, remote))
    return tunnel


def destroy_vtep_tunnel(remote_ip):
    local, remote, tunnel = get_vtep_tunnel(remote_ip)
    if tunnel:
        vlog.info("destroying tunnel record in vtep for remote_ip:%s"
                  % remote_ip)
        vtep_ctl("remove physical_switch %s tunnels %s "
                 "-- --if-exists destroy tunnel %s"
                 % (ps_name, tunnel, tunnel))


def add_bfd(remote_ip):
    # The VTEP emulator creates one OVS bridge for every logical switch.
    # Multiple logical switches can have multiple OVS tunnels to the
    # same machine (with different tunnel ids). But VTEP schema expects
    # a single BFD session between two physical locators. Therefore
    # create a separate bridge ('bfd_bridge') and create a single OVS tunnel
    # between two phsyical locators (using reference counter).
    if remote_ip in bfd_ref:
        bfd_ref[remote_ip] += 1
        return

    vlog.info("adding bfd tunnel for remote_ip:%s" % remote_ip)

    port_name = "bfd" + remote_ip
    # Don't enable BFD yet. Enabling or disabling BFD is based on
    # the controller setting a value in VTEP DB's tunnel record.
    ovs_vsctl("--may-exist add-port %s %s "
              " -- set Interface %s type=vxlan options:remote_ip=%s"
              % (bfd_bridge, port_name, port_name, remote_ip))
    bfd_ref[remote_ip] = 1

    # Ideally, we should create a 'tunnel' record in the VTEP DB here.
    # To create a 'tunnel' record, we need 2 entries in 'physical_locator'
    # table (one for local and one for remote). But, 'physical_locator'
    # can be created/destroyed asynchronously when the remote controller
    # adds/removes entries in Ucast_Macs_Remote table. To prevent race
    # conditions, pass the responsibility of creating a 'tunnel' record
    # to run_bfd() which runs more often.


def del_bfd(remote_ip):
    if remote_ip in bfd_ref:
        if bfd_ref[remote_ip] == 1:
            port_name = "bfd" + remote_ip
            vlog.info("deleting bfd tunnel for remote_ip:%s" % remote_ip)
            ovs_vsctl("--if-exists del-port %s" % port_name)
            destroy_vtep_tunnel(remote_ip)
            del bfd_ref[remote_ip]
        else:
            bfd_ref[remote_ip] -= 1


def run_bfd():
    bfd_ports = ovs_vsctl("list-ports %s" % bfd_bridge).split()
    for port in bfd_ports:
        remote_ip = ovs_vsctl("get interface %s options:remote_ip" % port)
        tunnel = create_vtep_tunnel(remote_ip)
        if not tunnel:
            continue

        bfd_params_default = {'bfd_params:enable': 'false',
                              'bfd_params:min_rx': 1000,
                              'bfd_params:min_tx': 100,
                              'bfd_params:decay_min_rx': 0,
                              'bfd_params:cpath_down': 'false',
                              'bfd_params:check_tnl_key': 'false'}
        bfd_params_values = {}

        for key, default in six.iteritems(bfd_params_default):
            column = vtep_ctl("--if-exists get tunnel %s %s"
                               % (tunnel, key))
            if not column:
                bfd_params_values[key] = default
            else:
                bfd_params_values[key] = column

        for key, value in six.iteritems(bfd_params_values):
            new_key = key.replace('_params', '')
            ovs_vsctl("set interface %s %s=%s" % (port, new_key, value))

        bfd_status = ['bfd_status:state', 'bfd_status:forwarding',
                      'bfd_status:diagnostic', 'bfd_status:remote_state',
                      'bfd_status:remote_diagnostic']
        for key in bfd_status:
            value = ovs_vsctl("--if-exists get interface %s %s" % (port, key))
            if value:
                vtep_ctl("set tunnel %s %s=%s" % (tunnel, key, value))
            else:
                new_key = key.replace('bfd_status:', '')
                vtep_ctl("remove tunnel %s bfd_status %s" % (tunnel, new_key))

        vtep_ctl("set tunnel %s bfd_status:enabled=%s"
                 % (tunnel, bfd_params_values['bfd_params:enable']))

        # Add the defaults as described in VTEP schema to make it explicit.
        bfd_lconf_default = {'bfd_config_local:bfd_dst_ip': '169.254.1.0',
                             'bfd_config_local:bfd_dst_mac':
                                    '00:23:20:00:00:01'}
        for key, value in six.iteritems(bfd_lconf_default):
            vtep_ctl("set tunnel %s %s=%s" % (tunnel, key, value))

        # bfd_config_remote options from VTEP DB should be populated to
        # corresponding OVS DB values.
        bfd_dst_ip = vtep_ctl("--if-exists get tunnel %s "
                              "bfd_config_remote:bfd_dst_ip" % (tunnel))
        if not bfd_dst_ip:
            bfd_dst_ip = "169.254.1.1"

        bfd_dst_mac = vtep_ctl("--if-exists get tunnel %s "
                              "bfd_config_remote:bfd_dst_mac" % (tunnel))
        if not bfd_dst_mac:
            bfd_dst_mac = "00:23:20:00:00:01"

        ovs_vsctl("set interface %s bfd:bfd_dst_ip=%s "
                  "bfd:bfd_remote_dst_mac=%s bfd:bfd_local_dst_mac=%s"
                  % (port, bfd_dst_ip,
                  bfd_lconf_default['bfd_config_local:bfd_dst_mac'],
                  bfd_dst_mac))


def getHexIp(ip):
    hexip ="0x"
    for i in ip.split('.'):
        if int(i) < 16:
            hexip += "0"+ hex(int(i))[2:]
        else:
            hexip += hex(int(i))[2:]

    return hexip

def add_binding(binding, ls):
    vlog.info("adding binding %s" % binding)

    vlan, pp_name = binding.split("-", 1)
    pbinding = binding + "-p"
    lbinding = binding + "-l"

    # Create a patch port that connects the VLAN+port to the lswitch.
    # Do them as two separate calls so if one side already exists, the
    # other side is created.
    ovs_vsctl("add-port %s %s "
              " -- set Interface %s type=patch options:peer=%s"
              % (ps_name, pbinding, pbinding, lbinding))
    ovs_vsctl("add-port %s %s "
              " -- set Interface %s type=patch options:peer=%s"
              % (ls.short_name, lbinding, lbinding, pbinding))

    port_no = ovs_vsctl("get Interface %s ofport" % pp_name)
    patch_no = ovs_vsctl("get Interface %s ofport" % pbinding)
    vlan_ = vlan.lstrip('0')
    if vlan_:
        ovs_ofctl("add-flow %s in_port=%s,dl_vlan=%s,action=strip_vlan,%s"
                  % (ps_name, port_no, vlan_, patch_no))
        ovs_ofctl("add-flow %s in_port=%s,action=mod_vlan_vid:%s,%s"
                  % (ps_name, patch_no, vlan_, port_no))
    else:
        ovs_ofctl("add-flow %s in_port=%s,action=%s"
                  % (ps_name, port_no, patch_no))
        ovs_ofctl("add-flow %s in_port=%s,action=%s"
                  % (ps_name, patch_no, port_no))

    # Create a logical_bindings_stats record.
    if not vlan_:
        vlan_ = "0"
    vtep_ctl("set physical_port %s vlan_stats:%s=@stats -- "
             "--id=@stats create logical_binding_stats packets_from_local=0"
             % (pp_name, vlan_))

    ls.add_lbinding(lbinding)
    Bindings[binding] = ls.name


def del_switch_binding(binding, ls):
    vlog.info("removing switch binding %s" % binding)

    lr_name, lif = binding.split("-", 1)
    lif_port_r = lif.strip("\"").partition("(")[0].strip() + "-r"
    lif_port_s = lif.strip("\"").partition("(")[0].strip() + "-s"

    lr = Lrouters[lr_name]
    lr.del_lbinding(lif_port_r, lif)
    ls.del_lbinding(lif_port_s)

    # Destroy the patch port that connects the lrouter to the lswitch
    ovs_vsctl("del-port %s %s -- del-port %s %s"
              % (lr.short_name, lif_port_r, ls.short_name, lif_port_s))

    del Switch_Bindings[binding]

def del_binding(binding, ls):
    vlog.info("removing binding %s" % binding)

    vlan, pp_name = binding.split("-", 1)
    pbinding = binding + "-p"
    lbinding = binding + "-l"

    port_no = ovs_vsctl("get Interface %s ofport" % pp_name)
    patch_no = ovs_vsctl("get Interface %s ofport" % pbinding)
    vlan_ = vlan.lstrip('0')
    if vlan_:
        ovs_ofctl("del-flows %s in_port=%s,dl_vlan=%s"
                  % (ps_name, port_no, vlan_))
        ovs_ofctl("del-flows %s in_port=%s" % (ps_name, patch_no))
    else:
        ovs_ofctl("--strict del-flows %s in_port=%s" % (ps_name, port_no))
        ovs_ofctl("--strict del-flows %s in_port=%s" % (ps_name, patch_no))

    ls.del_lbinding(lbinding)

    # Destroy the patch port that connects the VLAN+port to the lswitch
    ovs_vsctl("del-port %s %s -- del-port %s %s"
              % (ps_name, pbinding, ls.short_name, lbinding))

    # Remove the record that links vlan with stats in logical_binding_stats.
    vtep_ctl("remove physical_port %s vlan_stats %s" % (pp_name, vlan))

    del Bindings[binding]


def get_logical_switch_uuid(ls_name):
    column = vtep_ctl("--columns=_uuid find Logical_Switch "
                      "name=%s" % ls_name)
    return column.partition(":")[2].strip()

def get_switch_bindings():
    # get the total list of switch bindings from all routers
    New_Switch_Bindings = {}
    binding_lines = set(vtep_ctl("--columns=switch_binding find Logical_Router").splitlines())
    for line in binding_lines:
        binding_line = line.partition(":")[2].strip().strip("{}")
        if not binding_line:
            continue

        bindings = binding_line.split(",")

        # get lr name
        column = vtep_ctl("--columns=name find Logical_Router "
                          "switch_binding=\'%s\'" % binding_line)
        lr_name = column.partition(":")[2].strip()

        for binding in bindings:
            lif, ls_uuid = binding.split("=", 1)
            switch_binding = lr_name + "-" + lif.strip()
            if New_Switch_Bindings.has_key(switch_binding):
                ovs.util.ovs_fatal(0, "find duplicate lr-lif bindings (%s-%s)" % (lr_name, lif), vlog)

            ls_name = vtep_ctl("get Logical_Switch %s name" % ls_uuid).strip("\"")
            New_Switch_Bindings[switch_binding] = ls_name

    return New_Switch_Bindings

def handle_physical():
    # Gather physical ports except the patch ports we created
    ovs_ports = ovs_vsctl("list-ports %s" % ps_name).split()
    ovs_port_set = set([port for port in ovs_ports if port[-2:] != "-p"])

    vtep_pp_set = set(vtep_ctl("list-ports %s" % ps_name).split())

    for pp_name in ovs_port_set.difference(vtep_pp_set):
        vlog.info("adding %s to %s" % (pp_name, ps_name))
        vtep_ctl("add-port %s %s" % (ps_name, pp_name))

    for pp_name in vtep_pp_set.difference(ovs_port_set):
        vlog.info("deleting %s from %s" % (pp_name, ps_name))
        vtep_ctl("del-port %s %s" % (ps_name, pp_name))

    new_bindings = set()
    for pp_name in vtep_pp_set:
        binding_set = set(vtep_ctl("list-bindings %s %s"
                                   % (ps_name, pp_name)).splitlines())

        for b in binding_set:
            vlan, ls_name = b.split()
            if ls_name not in Lswitches:
                vlog.info("add ls %s" % (ls_name))
                Lswitches[ls_name] = Logical_Switch(ls_name, ps_name)

            binding = "%s-%s" % (vlan, pp_name)
            ls = Lswitches[ls_name]
            new_bindings.add(binding)

            if binding in Bindings:
                if Bindings[binding] == ls_name:
                    continue
                else:
                    del_binding(binding, Lswitches[Bindings[binding]])

            add_binding(binding, ls)

    dead_bindings = set(Bindings.keys()).difference(new_bindings)
    for binding in dead_bindings:
        ls_name = Bindings[binding]
        ls = Lswitches[ls_name]

        del_binding(binding, ls)

        if not len(ls.ports):
            ls.cleanup_ls()
            ovs_vsctl("del-br %s" % Lswitches[ls_name].short_name)
            vtep_ctl("clear-local-macs %s" % Lswitches[ls_name].name)
            del Lswitches[ls_name]


    # update logical router
    new_switch_bindings = get_switch_bindings()
    for b in new_switch_bindings:
        lr_name, lif = b.split("-",1)
        ls_name = new_switch_bindings[b]

        if lr_name not in Lrouters:
            vlog.info("add lr %s " % (lr_name))
            Lrouters[lr_name] = Logical_Router(lr_name)

        if ls_name not in Lswitches:
            vlog.info("add ls %s " % (ls_name))
            Lswitches[ls_name] = Logical_Switch(ls_name)

        lr = Lrouters[lr_name]
        ls = Lswitches[ls_name]

        if Switch_Bindings.has_key(b):
            if Switch_Bindings[b] == ls_name:
                continue
            else:
                del_switch_binding(switch_binding, Lswitches[Switch_Bindings[b]])

        Switch_Bindings[b] = ls_name
        lr.add_switch_binding(b, ls)

    dead_bindings = set(Switch_Bindings.keys()).difference(new_switch_bindings.keys())
    for binding in dead_bindings:
        lr_name, lif = binding.split("-",1)
        ls_name = Switch_Bindings[binding]

        ls = Lswitches[ls_name]
        del_switch_binding(binding, ls)

        if not len(ls.ports):
            ls.cleanup_ls()
            ovs_vsctl("del-br %s" % Lswitches[ls_name].short_name)
            vtep_ctl("clear-local-macs %s" % Lswitches[ls_name].name)
            del Lswitches[ls_name]

        lr = Lrouters[lr_name]
        if not len(lr.ports):
            ovs_vsctl("del-br %s" % lr.short_name)
            vtep_ctl("clear-local-macs %s" % lr.name)
            del Lrouters[lr_name]

def setup():
    br_list = ovs_vsctl("list-br").split()
    if (ps_name not in br_list):
        ovs.util.ovs_fatal(0, "couldn't find OVS bridge %s" % ps_name, vlog)

    global ps_type
    ps_type = ovs_vsctl("get Bridge %s datapath_type" % ps_name).strip('"')

    call_prog("vtep-ctl", ["set", "physical_switch", ps_name,
                           'description="OVS VTEP Emulator"'])

    tunnel_ips = vtep_ctl("get physical_switch %s tunnel_ips"
                          % ps_name).strip('[]"').split(", ")
    if len(tunnel_ips) != 1 or not tunnel_ips[0]:
        ovs.util.ovs_fatal(0, "exactly one 'tunnel_ips' should be set", vlog)

    global Tunnel_Ip
    Tunnel_Ip = tunnel_ips[0]

    ovs_ofctl("del-flows %s" % ps_name)

    # Remove any logical bridges from the previous run
    for br in br_list:
        if ovs_vsctl("br-get-external-id %s vtep_logical_switch"
                     % br) == "true":
            # Remove the remote side of any logical switch
            ovs_ports = ovs_vsctl("list-ports %s" % br).split()
            for port in ovs_ports:
                port_type = ovs_vsctl("get Interface %s type"
                                      % port).strip('"')
                if port_type != "patch":
                    continue

                peer = ovs_vsctl("get Interface %s options:peer"
                                 % port).strip('"')
                if (peer):
                    ovs_vsctl("del-port %s" % peer)

            ovs_vsctl("del-br %s" % br)

        if br == bfd_bridge:
            bfd_ports = ovs_vsctl("list-ports %s" % bfd_bridge).split()
            for port in bfd_ports:
                remote_ip = ovs_vsctl("get interface %s options:remote_ip"
                                      % port)
                destroy_vtep_tunnel(remote_ip)

            ovs_vsctl("del-br %s" % br)

    if ps_type:
        ovs_vsctl("add-br %s -- set Bridge %s datapath_type=%s"
                  % (bfd_bridge, bfd_bridge, ps_type))
    else:
        ovs_vsctl("add-br %s" % bfd_bridge)

    # Remove local-mac entries from the previous run.  Otherwise, if a vlan
    # binding is removed while the emulator is *not* running, the corresponding
    # local-mac entries are never cleaned up.
    vtep_ls = set(vtep_ctl("list-ls").split())
    for ls_name in vtep_ls:
        vtep_ctl("clear-local-macs %s" % ls_name)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("ps_name", metavar="PS-NAME",
                        help="Name of physical switch.")
    parser.add_argument("--root-prefix", metavar="DIR",
                        help="Use DIR as alternate root directory"
                        " (for testing).")
    parser.add_argument("--version", action="version",
                        version="%s %s" % (ovs.util.PROGRAM_NAME, VERSION))

    ovs.vlog.add_args(parser)
    ovs.daemon.add_args(parser)
    args = parser.parse_args()
    ovs.vlog.handle_args(args)
    ovs.daemon.handle_args(args)

    global root_prefix
    if args.root_prefix:
        root_prefix = args.root_prefix

    global ps_name
    ps_name = args.ps_name

    ovs.daemon.daemonize()

    ovs.unixctl.command_register("exit", "", 0, 0, unixctl_exit, None)
    error, unixctl = ovs.unixctl.server.UnixctlServer.create(None,
                                                             version=VERSION)
    if error:
        ovs.util.ovs_fatal(error, "could not create unixctl server", vlog)

    setup()

    while True:
        unixctl.run()
        if exiting:
            break

        handle_physical()

        for ls_name, ls in six.iteritems(Lswitches):
            ls.run()

        for lr_name, lr in Lrouters.items():
            lr.run()

        run_bfd()

        poller = ovs.poller.Poller()
        unixctl.wait(poller)
        poller.timer_wait(1000)
        poller.block()

    unixctl.close()

if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        # Let system.exit() calls complete normally
        raise
    except:
        vlog.exception("traceback")
        sys.exit(ovs.daemon.RESTART_EXIT_CODE)
